<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>VR Viewer – Shinecon</title>
  <script src="https://unpkg.com/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#000; }
    #renderCanvas { width:100%; height:100%; touch-action:none; display:block; }
    .ui {
      position: fixed; left: 12px; bottom: 12px; z-index: 2;
      font-family: system-ui, sans-serif; color: #fff; opacity: .9;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 10px;
    }
    .ui button { font-size:14px; padding:6px 10px; border-radius:8px; border:0; }
  </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>
<div class="ui">
  <button id="resetCam">Recentrar câmera</button>
</div>

<script>
(async function () {
  try { window._xrPolyfill = new WebXRPolyfill(); } catch (e) {}

  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true, {  antialias: true, stencil: true, preserveDrawingBuffer: true });

  const createScene = async () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color4(0,0,0,1);

    scene.imageProcessingConfiguration.exposure = 1.2;
    scene.imageProcessingConfiguration.contrast = 1.1;

    const camera = new BABYLON.ArcRotateCamera("cam",
      BABYLON.Tools.ToRadians(150), BABYLON.Tools.ToRadians(60),
      3.5, BABYLON.Vector3.Zero(), scene);
    camera.wheelPrecision = 60;
    camera.lowerRadiusLimit = 1.2;
    camera.upperRadiusLimit = 20;
    camera.attachControl(canvas, true);

    const env = scene.createDefaultEnvironment({
      createGround: true,
      groundSize: 20,
      skyboxSize: 1000,
      enableGroundShadow: true,
      groundOpacity: 0.0 
    });
    if (env && env.environmentTexture) {
      env.environmentTexture.level = 1.0;
    }

    const dir = new BABYLON.DirectionalLight("dir", new BABYLON.Vector3(-1, -2, -1), scene);
    dir.intensity = 0.6;
    const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene);
    hemi.intensity = 0.6;

    const modelUrl = "./models/kombi.glb";
    await BABYLON.SceneLoader.AppendAsync("", modelUrl, scene);

    const meshes = scene.meshes.filter(m => m && m.name !== "BackgroundSkybox" && m.name !== "BackgroundPlane");
    let min = new BABYLON.Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
    let max = new BABYLON.Vector3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
    meshes.forEach(m => {
      const b = m.getBoundingInfo().boundingBox;
      min = BABYLON.Vector3.Minimize(min, b.minimumWorld);
      max = BABYLON.Vector3.Maximize(max, b.maximumWorld);
    });
    const size = max.subtract(min);
    const center = min.add(size.scale(0.5));
    const root = new BABYLON.TransformNode("root", scene);
    meshes.forEach(m => m.setParent(root));
    root.position = root.position.subtract(center);

    const targetSize = 2.0; // quão grande deve aparecer na tela
    const maxDim = Math.max(size.x, size.y, size.z) || 1.0;
    const scale = targetSize / maxDim;
    root.scaling = new BABYLON.Vector3(scale, scale, scale);

    try {
      const xr = await scene.createDefaultXRExperienceAsync({
        floorMeshes: [],
        disableDefaultUI: false
      });
      if (!xr.baseExperience) {
        console.warn("WebXR indisponível. Sem VR neste dispositivo.");
      }
    } catch (e) {
      console.warn("Falha ao iniciar WebXR:", e);
    }

    document.getElementById("resetCam").onclick = () => {
      camera.setPosition(new BABYLON.Vector3(0, 2.2, -3.5));
      camera.setTarget(BABYLON.Vector3.Zero());
    };

    return scene;
  };

  const scene = await createScene();
  engine.runRenderLoop(() => scene.render());
  window.addEventListener("resize", () => engine.resize());
})();
</script>
</body>
</html>